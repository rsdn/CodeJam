<#@ template debug="false" hostspecific="false" language="C#" #><#@
 include file="$(SolutionDir)Build\T4\Autogenerated.ttinclude" #>
using System;
using System.Diagnostics.CodeAnalysis;

using JetBrains.Annotations;

namespace CodeJam
{
<#
	for (var i = 2; i <= 8; i++)
	{
		var types = string.Join(", ", Enumerable.Range(1, i).Select(j => $"T{j}"));
#>
	/// <summary>
	/// Value type tagged union for <#= i #> types.
	/// </summary>
<#
		for (var k = 1; k <= i; k++)
		{
#>
	/// <typeparam name="T<#= k #>">Type of case <#= k #></typeparam>
<#
		}
#>
	public struct ValueOneOf<<#= types #>> : IOneOf<<#= types #>>, IEquatable<ValueOneOf<<#= types #>>>
	{
		private Cases _curCase;
		private object _value;

		private ValueOneOf(object value, Cases @case)
		{
			_value = value;
			_curCase = @case;
		}

		private enum Cases
		{
<#
		for (var k = 1; k <= i; k++)
		{
#>
			Case<#= k #>,
<#
		}
#>
		}

<#
		for (var k = 1; k <= i; k++)
		{
#>
		/// <inheritdoc />
		public bool IsCase<#= k #> => _curCase == Cases.Case<#= k #>;

		/// <summary>
		/// Creates instance of <see cref="OneOf{<#= types #>}"/> for value of type <typeparamref name="T<#= k #>"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T<#= k #>"/> to create instance from.</param>
		/// <returns>Value of <see cref="ValueOneOf{<#= types #>}"/>.</returns>
		public static ValueOneOf<<#= types #>> Create(T<#= k #> value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new ValueOneOf<<#= types #>>(value, Cases.Case<#= k #>);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="ValueOneOf{<#= types #>}"/> for value of type <typeparamref name="T<#= k #>"/>.</returns>
		public static implicit operator ValueOneOf<<#= types #>>(T<#= k #> value) => Create(value);

<#
		}
#>

		/// <inheritdoc />
		public TResult GetValue<TResult>(<#= List(i, j => $"Func<T{j}, TResult> case{j}Selector") #>)
		{
			switch (_curCase)
			{
<#
		for (var k = 1; k <= i; k++)
		{
#>
				case Cases.Case<#= k #> : return case<#= k #>Selector((T<#= k #>)_value);
<#
		}
#>
				default: throw CodeExceptions.InvalidOperation("Wrong state");
			}
		}

		/// <inheritdoc />
		public void Do(<#= List(i, j => $"Action<T{j}> case{j}Action") #>)
		{
<#
		for (var k = 1; k <= i; k++)
		{
#>
			Code.NotNull(case<#= k #>Action, nameof (case<#= k #>Action));
<#
		}
#>
			switch (_curCase)
			{
<#
		for (var k = 1; k <= i; k++)
		{
#>
				case Cases.Case<#= k #> : case<#= k #>Action((T<#= k #>)_value); break;
<#
		}
#>
				default: throw CodeExceptions.InvalidOperation("Wrong state");
			}
		}

		/// <inheritdoc />
		public bool Equals([AllowNull] ValueOneOf<<#= types #>> other)
		{
			return Equals(_value, other._value);
		}

		/// <inheritdoc />
		public override bool Equals([AllowNull] object obj)
		{
			if (ReferenceEquals(null, obj)) return false;
			return obj is ValueOneOf<<#= types #>> && Equals((ValueOneOf<<#= types #>>)obj);
		}

		/// <summary>
		/// Equality operator.
		/// </summary>
		/// <param name="left">Left parameter.</param>
		/// <param name="right">Right parameter</param>
		/// <returns><c>true</c> if <paramref name="left"/> equals to <paramref name="right"/></returns>
		public static bool operator ==(ValueOneOf<<#= types #>> left, ValueOneOf<<#= types #>> right)
		{
			return left.Equals(right);
		}

		/// <summary>
		/// Unequality operator.
		/// </summary>
		/// <param name="left">Left parameter.</param>
		/// <param name="right">Right parameter</param>
		/// <returns><c>true</c> if <paramref name="left"/> not equals to <paramref name="right"/></returns>
		public static bool operator !=(ValueOneOf<<#= types #>> left, ValueOneOf<<#= types #>> right)
		{
			return !left.Equals(right);
		}

		/// <inheritdoc />
		public override int GetHashCode() => _value.GetHashCode();
	}

<#
	}
#>
}