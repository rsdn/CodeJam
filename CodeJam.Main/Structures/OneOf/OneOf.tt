<#@ template debug="false" hostspecific="false" language="C#" #><#@
 include file="$(SolutionDir)Build\T4\Autogenerated.ttinclude" #>
using System;

using JetBrains.Annotations;

namespace CodeJam
{
<#
	for (var i = 2; i <= 8; i++)
	{
		var types = List(i, j => $"T{j}");
#>
	/// <summary>
	/// Tagged union for <#= i #> types.
	/// </summary>
<#
		for (var k = 1; k <= i; k++)
		{
#>
	/// <typeparam name="T<#= k #>">Type of case <#= k #></typeparam>
<#
		}
#>
	public abstract class OneOf<<#= types #>> : IOneOf<<#= types #>>, IEquatable<OneOf<<#= types #>>>
	{
<#
		for (var k = 1; k <= i; k++)
		{
#>
		/// <inheritdoc />
		public abstract bool IsCase<#= k #> { get; }

<#
		}
#>
		/// <inheritdoc />
		public abstract TResult GetValue<TResult>(<#= List(i, j => $"Func<T{j}, TResult> case{j}Selector") #>);

		/// <inheritdoc />
		public abstract void Do(<#= List(i, j => $"Action<T{j}> case{j}Action") #>);

		/// <inheritdoc />
		public abstract bool Equals(OneOf<<#= types #>>? other);

		/// <inheritdoc />
		public override bool Equals(object? obj)
		{
			if (ReferenceEquals(null, obj)) return false;
			if (ReferenceEquals(this, obj)) return true;
			return obj is OneOf<<#= types #>> && Equals((OneOf<<#= types #>>)obj);
		}

		/// <inheritdoc />
		public override int GetHashCode()
		{
			throw new NotImplementedException();
		}

		/// <summary>
		/// Equality operator.
		/// </summary>
		/// <param name="left">Left parameter.</param>
		/// <param name="right">Right parameter</param>
		/// <returns><c>true</c> if <paramref name="left"/> equals to <paramref name="right"/></returns>
		public static bool operator ==(OneOf<<#= types #>> left, OneOf<<#= types #>> right) => Equals(left, right);

		/// <summary>
		/// Unequality operator.
		/// </summary>
		/// <param name="left">Left parameter.</param>
		/// <param name="right">Right parameter</param>
		/// <returns><c>true</c> if <paramref name="left"/> not equals to <paramref name="right"/></returns>
		public static bool operator !=(OneOf<<#= types #>> left, OneOf<<#= types #>> right) => !Equals(left, right);

<#
		for (var k = 1; k <= i; k++)
		{
#>
		private sealed class Case<#= k #> : OneOf<<#= types #>>
		{
			private T<#= k #> _value;

			public Case<#= k #>(T<#= k #> value)
			{
				_value = value;
			}

<#
			for (var l = 1; l <= i; l++)
			{
#>
			public override bool IsCase<#= l #> => <#= l == k ? "true" : "false" #>;
<#
			}
#>

			public override TResult GetValue<TResult>(<#= List(i, j => $"Func<T{j}, TResult> case{j}Selector") #>) => case<#= k #>Selector(_value);

			public override void Do(<#= List(i, j => $"Action<T{j}> case{j}Action") #>) => case<#= k #>Action(_value);

			public override bool Equals(OneOf<<#= types #>>? other) => Equals(other as Case<#= k #>);

			public override int GetHashCode() => _value.GetHashCode();
		}

		/// <summary>
		/// Creates instance of <see cref="OneOf{<#= types #>}"/> for value of type <typeparamref name="T<#= k #>"/>.
		/// </summary>
		/// <param name="value">Value of type <typeparamref name="T<#= k #>"/> to create instance from.</param>
		/// <returns>Value of <see cref="OneOf{<#= types #>}"/>.</returns>
		public static OneOf<<#= types #>> Create(T<#= k #> value)
		{
			if (value == null)
				throw CodeExceptions.ArgumentNull(nameof (value));
			return new Case<#= k #>(value);
		}

		/// <summary>
		/// Implicit cast operator.
		/// </summary>
		/// <param name="value">The parameter.</param>
		/// <returns>Instance of <see cref="OneOf{<#= types #>}"/> for value of type <typeparamref name="T<#= k #>"/>.</returns>
		public static implicit operator OneOf<<#= types #>>(T<#= k #> value) => Create(value);

<#
		}
#>
	}

<#
	}
#>
}