<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ include file="$(SolutionDir)Build\T4\Autogenerated.ttinclude" #>
using System;
using System.Threading;

using CodeJam.Collections;

using JetBrains.Annotations;

namespace CodeJam
{
	partial class Algorithms
	{
<#
	for (var i = 2; i <= 7; i++)
		GenerateMethod(i);
#>
	}
}
<#+
	private void GenerateMethod(int argCount)
	{
		var typeArgs = List(argCount, i => "TArg" + i);
		var args = List(argCount, i => "arg" + i);
#>
		/// <summary>
		/// Caches function value for specific arguments.
		/// </summary>
		/// <param name="func">Function to memoize.</param>
		/// <param name="threadSafe">If true - returns thread safe implementation</param>
<#+
		for (var i = 1; i <= argCount; i++)
		{
#>
		/// <typeparam name="TArg<#= i #>">Type of argument <#= i #></typeparam>
<#+
		}
#>
		/// <typeparam name="TResult">Type of result</typeparam>
		/// <returns>Memoized function</returns>
		[Pure, System.Diagnostics.Contracts.Pure]
		public static Func<<#= typeArgs #>, TResult> Memoize<<#= typeArgs #>, TResult>(
				this Func<<#= typeArgs #>, TResult> func,
				bool threadSafe = false) =>
			Memoize(func, threadSafe ? LazyThreadSafetyMode.ExecutionAndPublication : LazyThreadSafetyMode.None);

		/// <summary>
		/// Caches function value for specific arguments.
		/// </summary>
		/// <param name="func">Function to memoize.</param>
		/// <param name="threadSafety">One of the enumeration values that specifies the thread safety mode.</param>
<#+
		for (var i = 1; i <= argCount; i++)
		{
#>
		/// <typeparam name="TArg<#= i #>">Type of argument <#= i #></typeparam>
<#+
		}
#>
		/// <typeparam name="TResult">Type of result</typeparam>
		/// <returns>Memoized function</returns>
		[Pure, System.Diagnostics.Contracts.Pure]
		public static Func<<#= typeArgs #>, TResult> Memoize<<#= typeArgs #>, TResult>(
			this Func<<#= typeArgs #>, TResult> func,
			LazyThreadSafetyMode threadSafety)
		{
			var map =
				LazyDictionary.Create<(<#= typeArgs #>), TResult>(
					key => func(<#= List(argCount, i => "key.Item" + i) #>),
					threadSafety);
			return (<#= args #>) => map[(<#= args #>)];
		}

<#+
	}
#>