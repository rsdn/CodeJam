<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ include file="$(SolutionDir)T4.Reusable\Autogenerated.ttinclude" #>
<#@ include file="Operators.ttinclude" #>
using System;
using System.Linq.Expressions;

using JetBrains.Annotations;

using static CodeJam.Arithmetic.OperatorsFactory;

namespace CodeJam.Arithmetic
{
	/// <summary>
	/// Callbacks for common arithmetic actions.
	/// Look at OperatorsPerformanceTest to see why.
	/// </summary>
	static partial class Operators<T>
	{
<#
	foreach (var op in ops)
	{
		WriteRegionLine(op.OpType.ToString());

		switch (op.OpType)
		{
			case OpType.Unary:
				EmitUnary(op);
				break;
			case OpType.Comparison:
				EmitComparison(op);
				break;
			default:
				EmitBinary(op);
				break;
		}
	}
	FlushRegions();
#>
	}
}<#+

	private void EmitUnary(OpInfo op)
	{
		if (op.Type == ExpressionType.OnesComplement)
			return;
#>
		/// <summary>Gets <#=ToLower(op.Comment)#></summary>
		[NotNull]
		public static Func<T, T> <#=op.Name#> => <#=op.HelperClass#>.LazyValue.Value;

		/// <summary>
		/// The helper class.
		/// </summary>
		private static class <#=op.HelperClass#>
		{
			/// <summary>Gets the operator factory.</summary>
			public static readonly Lazy<Func<T, T>> LazyValue = new Lazy<Func<T, T>>(Factory, _lazyMode);

			/// <summary>Returns the operator function.</summary>
			/// <returns>The operator function.</returns>
			private static Func<T, T> Factory() => UnaryOperator<T>(ExpressionType.<#=op.Type#>);
		}
<#+
	}

	private void EmitComparison(OpInfo op)
	{
#>
		/// <summary>Gets <#=ToLower(op.Comment)#></summary>
		[NotNull]
		public static Func<T, T, bool> <#=op.Name#> => <#=op.HelperClass#>.LazyValue.Value;

		/// <summary>
		/// The helper class.
		/// </summary>
		private static class <#=op.HelperClass#>
		{
			/// <summary>Gets the operator factory.</summary>
			public static readonly Lazy<Func<T, T, bool>> LazyValue = new Lazy<Func<T, T, bool>>(Factory, _lazyMode);

			/// <summary>Returns the operator function.</summary>
			/// <returns>The operator function.</returns>
			private static Func<T, T, bool> Factory() => ComparisonOperator<T>(ExpressionType.<#=op.Type#>);
		}
<#+
	}

	private void EmitBinary(OpInfo op)
	{
#>
		/// <summary>Gets <#=ToLower(op.Comment)#></summary>
		[NotNull]
		public static Func<T, T, T> <#=op.Name#> => <#=op.HelperClass#>.LazyValue.Value;

		/// <summary>
		/// Represents the helper class.
		/// </summary>
		private static class <#=op.HelperClass#>
		{
			/// <summary>Gets the operator factory.</summary>
			public static readonly Lazy<Func<T, T, T>> LazyValue = new Lazy<Func<T, T, T>>(Factory, _lazyMode);

			/// <summary>Returns the operator function.</summary>
			/// <returns>The operator function.</returns>
			private static Func<T, T, T> Factory() => BinaryOperator<T>(ExpressionType.<#=op.Type#>);
		}
<#+
	}
#>