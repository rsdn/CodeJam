<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ include file="$(SolutionDir)Build\T4\Autogenerated.ttinclude" #>
<#@ include file="Operators.ttinclude" #>
using System;
using System.Linq.Expressions;

using JetBrains.Annotations;

using static CodeJam.Arithmetic.OperatorsFactory;

#nullable enable
namespace CodeJam.Arithmetic
{
	/// <summary>
	/// Callbacks for common arithmetic actions.
	/// </summary>
	static partial class Operators<T>
	{
<#
	foreach (var op in ops)
	{
		WriteRegionLine(op.OpType.ToString());

		switch (op.OpType)
		{
			case OpType.Unary:
				EmitUnary(op);
				break;
			case OpType.Comparison:
				EmitComparison(op);
				break;
			default:
				EmitBinary(op);
				break;
		}
	}
	FlushRegions();
#>
	}
}<#+
	private void EmitUnary(OpInfo op)
	{
		if (op.Type == ExpressionType.OnesComplement)
			return;
#>
		/// <summary>Gets <#= ToLower(op.Comment) #></summary>
		public static Func<T, T> <#= op.Name #> => <#= op.HelperClass #>.LazyValue.Value;

		/// <summary>
		/// The helper class.
		/// </summary>
		private static class <#= op.HelperClass #>
		{
			/// <summary>Gets the operator factory.</summary>
			public static readonly Lazy<Func<T, T>> LazyValue = new Lazy<Func<T, T>>(Factory, _lazyMode);

			/// <summary>Returns the operator function.</summary>
			/// <returns>The operator function.</returns>
			private static Func<T, T> Factory() => UnaryOperator<T>(ExpressionType.<#= op.Type #>);
		}
<#+
	}

	private void EmitComparison(OpInfo op)
	{
#>
		/// <summary>Gets <#= ToLower(op.Comment) #></summary>
		public static Func<T?, T?, bool> <#= op.Name #> => <#= op.HelperClass #>.LazyValue.Value;

		/// <summary>
		/// The helper class.
		/// </summary>
		private static class <#= op.HelperClass #>
		{
			/// <summary>Gets the operator factory.</summary>
			public static readonly Lazy<Func<T?, T?, bool>> LazyValue = new (Factory, _lazyMode);

			/// <summary>Returns the operator function.</summary>
			/// <returns>The operator function.</returns>
			private static Func<T?, T?, bool> Factory() => ComparisonOperator<T>(ExpressionType.<#= op.Type #>);
		}
<#+
	}

	private void EmitBinary(OpInfo op)
	{
#>
		/// <summary>Gets <#= ToLower(op.Comment) #></summary>
		public static Func<T, T, T> <#= op.Name #> => <#= op.HelperClass #>.LazyValue.Value;

		/// <summary>
		/// Represents the helper class.
		/// </summary>
		private static class <#= op.HelperClass #>
		{
			/// <summary>Gets the operator factory.</summary>
			public static readonly Lazy<Func<T, T, T>> LazyValue = new Lazy<Func<T, T, T>>(Factory, _lazyMode);

			/// <summary>Returns the operator function.</summary>
			/// <returns>The operator function.</returns>
			private static Func<T, T, T> Factory() => BinaryOperator<T>(ExpressionType.<#= op.Type #>);
		}
<#+
	}
#>