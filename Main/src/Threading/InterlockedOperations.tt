<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ include file="$(SolutionDir)T4.Reusable\Autogenerated.ttinclude" #>
using System;
using System.Threading;

using JetBrains.Annotations;

namespace CodeJam.Threading
{
	/// <summary>
	/// Provides a helper class for initializing a values in a thread-safe manner.
	/// </summary>
	[PublicAPI]
	public static class InterlockedOperations
	{
<#
		OverladsFor("double", false);
		WriteLine("");
		OverladsFor("float", false);
		WriteLine("");
		OverladsFor("int", false);
		WriteLine("");
		OverladsFor("long", false);
		WriteLine("");
		OverladsFor("T", true);#>
	}
}<#+
		private void OverladsFor(string typeName, bool forRefTypes)
		{
			var t = typeName;
			var tXmlDoc = forRefTypes? 
				"\r\n\t\t/// <typeparam name=\"" + typeName + "\">Type of value.</typeparam>" :
				"";
			var tXmlT = forRefTypes? "{" + typeName + "}" : "";
			var tT = forRefTypes? "<" + typeName + ">" : "";
			var tNotNull = forRefTypes? "[NotNull] " + typeName : typeName;
			var tWhere = forRefTypes? "\r\n\t\t\twhere " + typeName + " : class" : "";#>
		#region <#=t#> overloads
		/// <summary>
		/// Initialize the value referenced by <paramref name="target"/> in a thread-safe manner.
		/// The value is changed to <paramref name="value"/> only if the current value is default(<#=t#>).
		/// </summary><#=tXmlDoc#>
		/// <param name="target">Reference to the target location.</param>
		/// <param name="value">The value to use if the target is equal to default(<#=t#>).</param>
		/// <returns>
		/// The new value referenced by <paramref name="target"/>.
		/// Note that this is nearly always more useful than the usual
		/// return from <see cref="Interlocked.CompareExchange<#=tXmlT#>(ref <#=t#>, <#=t#>, <#=t#>)"/>
		/// because it saves another read to <paramref name="target"/>.
		/// </returns>
		public static <#=t#> Initialize<#=tT#>(ref <#=t#> target, <#=tNotNull#> value)<#=tWhere#> =>
			Initialize(ref target, value, default(<#=t#>));

		/// <summary>
		/// Initialize the value referenced by <paramref name="target"/> in a thread-safe manner.
		/// The value is changed to <paramref name="initializedValue"/> only if the current value
		/// is <paramref name="uninitializedValue"/>.
		/// </summary><#=tXmlDoc#>
		/// <param name="target">Reference to the target location.</param>
		/// <param name="initializedValue">The value to use if the target is currently uninitialized.</param>
		/// <param name="uninitializedValue">The uninitialized value.</param>
		/// <returns>
		/// The new value referenced by <paramref name="target"/>.
		/// Note that this is nearly always more useful than the usual
		/// return from <see cref="Interlocked.CompareExchange<#=tXmlT#>(ref <#=t#>, <#=t#>, <#=t#>)"/>
		/// because it saves another read to <paramref name="target"/>.
		/// </returns>
		public static <#=t#> Initialize<#=tT#>(ref <#=t#> target, <#=t#> initializedValue, <#=t#> uninitializedValue)<#=tWhere#>
		{
			DebugCode.AssertArgument(
				initializedValue != uninitializedValue,
				nameof(initializedValue),
				"The values of uninitializedValue and initializedValue should not match");

			var oldValue = Interlocked.CompareExchange(ref target, initializedValue, uninitializedValue);
			return oldValue == uninitializedValue ? initializedValue : oldValue;
		}

		/// <summary>
		/// Implements lock-free update pattern implementation based on compare-and-swap loop
		/// </summary>
		/// <remarks>
		/// Uses the same approach that used by c# compiler in event subscription methods
		/// </remarks>
		// BASEDON: https://github.com/dotnet/roslyn/blob/56f605c41915317ccdb925f66974ee52282609e7/src/Compilers/Core/Portable/InternalUtilities/ThreadSafeFlagOperations.cs
		public static <#=t#> Update<#=tT#>(ref <#=t#> value, Func<<#=t#>, <#=t#>> updateCallback)<#=tWhere#>
		{
			<#=t#> oldState, newState;
			do
			{
				oldState = value;
				newState = updateCallback(oldState);
			}
			while (Interlocked.CompareExchange(ref value, newState, oldState) != oldState);
			return newState;
		}

		/// <summary>
		/// Implements lock-free update pattern implementation based on compare-and-swap loop
		/// </summary>
		/// <remarks>
		/// Uses the same approach that used by c# compiler in event subscription methods
		/// </remarks>
		// BASEDON: https://github.com/dotnet/roslyn/blob/56f605c41915317ccdb925f66974ee52282609e7/src/Compilers/Core/Portable/InternalUtilities/ThreadSafeFlagOperations.cs
		public static <#=t#> Update<#=tT#>(ref <#=t#> value, <#=t#> newValue, Func<<#=t#>, <#=t#>, <#=t#>> updateCallback)<#=tWhere#>
		{
			<#=t#> oldState, newState;
			do
			{
				oldState = value;
				newState = updateCallback(oldState, newValue);
			}
			while (Interlocked.CompareExchange(ref value, newState, oldState) != oldState);
			return newState;
		}
		#endregion
<#+}#>