//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Threading;

using JetBrains.Annotations;

namespace CodeJam.Threading
{
	/// <summary>
	/// Provides a helper class for initializing a values in a thread-safe manner.
	/// </summary>
	[PublicAPI]
	public static class InterlockedOperations
	{
		#region double overloads
		/// <summary>
		/// Initialize the value referenced by <paramref name="target"/> in a thread-safe manner.
		/// The value is changed to <paramref name="value"/> only if the current value is default(double).
		/// </summary>
		/// <param name="target">Reference to the target location.</param>
		/// <param name="value">The value to use if the target is equal to default(double).</param>
		/// <returns>
		/// The new value referenced by <paramref name="target"/>.
		/// Note that this is nearly always more useful than the usual
		/// return from <see cref="Interlocked.CompareExchange(ref double, double, double)"/>
		/// because it saves another read to <paramref name="target"/>.
		/// </returns>
		public static double Initialize(ref double target, double value) =>
			Initialize(ref target, value, default(double));

		/// <summary>
		/// Initialize the value referenced by <paramref name="target"/> in a thread-safe manner.
		/// The value is changed to <paramref name="initializedValue"/> only if the current value
		/// is <paramref name="uninitializedValue"/>.
		/// </summary>
		/// <param name="target">Reference to the target location.</param>
		/// <param name="initializedValue">The value to use if the target is currently uninitialized.</param>
		/// <param name="uninitializedValue">The uninitialized value.</param>
		/// <returns>
		/// The new value referenced by <paramref name="target"/>.
		/// Note that this is nearly always more useful than the usual
		/// return from <see cref="Interlocked.CompareExchange(ref double, double, double)"/>
		/// because it saves another read to <paramref name="target"/>.
		/// </returns>
		public static double Initialize(ref double target, double initializedValue, double uninitializedValue)
		{
			DebugCode.AssertArgument(
				initializedValue != uninitializedValue,
				nameof(initializedValue),
				"The values of uninitializedValue and initializedValue should not match");

			var oldValue = Interlocked.CompareExchange(ref target, initializedValue, uninitializedValue);
			return oldValue == uninitializedValue ? initializedValue : oldValue;
		}

		/// <summary>
		/// Implements lock-free update pattern implementation based on compare-and-swap loop
		/// </summary>
		/// <remarks>
		/// Uses the same approach that used by c# compiler in event subscription methods
		/// </remarks>
		// BASEDON: https://github.com/dotnet/roslyn/blob/56f605c41915317ccdb925f66974ee52282609e7/src/Compilers/Core/Portable/InternalUtilities/ThreadSafeFlagOperations.cs
		public static double Update(ref double value, Func<double, double> updateCallback)
		{
			double oldState, newState;
			do
			{
				oldState = value;
				newState = updateCallback(oldState);
			}
			while (Interlocked.CompareExchange(ref value, newState, oldState) != oldState);
			return newState;
		}

		/// <summary>
		/// Implements lock-free update pattern implementation based on compare-and-swap loop
		/// </summary>
		/// <remarks>
		/// Uses the same approach that used by c# compiler in event subscription methods
		/// </remarks>
		// BASEDON: https://github.com/dotnet/roslyn/blob/56f605c41915317ccdb925f66974ee52282609e7/src/Compilers/Core/Portable/InternalUtilities/ThreadSafeFlagOperations.cs
		public static double Update(ref double value, double newValue, Func<double, double, double> updateCallback)
		{
			double oldState, newState;
			do
			{
				oldState = value;
				newState = updateCallback(oldState, newValue);
			}
			while (Interlocked.CompareExchange(ref value, newState, oldState) != oldState);
			return newState;
		}
		#endregion

		#region float overloads
		/// <summary>
		/// Initialize the value referenced by <paramref name="target"/> in a thread-safe manner.
		/// The value is changed to <paramref name="value"/> only if the current value is default(float).
		/// </summary>
		/// <param name="target">Reference to the target location.</param>
		/// <param name="value">The value to use if the target is equal to default(float).</param>
		/// <returns>
		/// The new value referenced by <paramref name="target"/>.
		/// Note that this is nearly always more useful than the usual
		/// return from <see cref="Interlocked.CompareExchange(ref float, float, float)"/>
		/// because it saves another read to <paramref name="target"/>.
		/// </returns>
		public static float Initialize(ref float target, float value) =>
			Initialize(ref target, value, default(float));

		/// <summary>
		/// Initialize the value referenced by <paramref name="target"/> in a thread-safe manner.
		/// The value is changed to <paramref name="initializedValue"/> only if the current value
		/// is <paramref name="uninitializedValue"/>.
		/// </summary>
		/// <param name="target">Reference to the target location.</param>
		/// <param name="initializedValue">The value to use if the target is currently uninitialized.</param>
		/// <param name="uninitializedValue">The uninitialized value.</param>
		/// <returns>
		/// The new value referenced by <paramref name="target"/>.
		/// Note that this is nearly always more useful than the usual
		/// return from <see cref="Interlocked.CompareExchange(ref float, float, float)"/>
		/// because it saves another read to <paramref name="target"/>.
		/// </returns>
		public static float Initialize(ref float target, float initializedValue, float uninitializedValue)
		{
			DebugCode.AssertArgument(
				initializedValue != uninitializedValue,
				nameof(initializedValue),
				"The values of uninitializedValue and initializedValue should not match");

			var oldValue = Interlocked.CompareExchange(ref target, initializedValue, uninitializedValue);
			return oldValue == uninitializedValue ? initializedValue : oldValue;
		}

		/// <summary>
		/// Implements lock-free update pattern implementation based on compare-and-swap loop
		/// </summary>
		/// <remarks>
		/// Uses the same approach that used by c# compiler in event subscription methods
		/// </remarks>
		// BASEDON: https://github.com/dotnet/roslyn/blob/56f605c41915317ccdb925f66974ee52282609e7/src/Compilers/Core/Portable/InternalUtilities/ThreadSafeFlagOperations.cs
		public static float Update(ref float value, Func<float, float> updateCallback)
		{
			float oldState, newState;
			do
			{
				oldState = value;
				newState = updateCallback(oldState);
			}
			while (Interlocked.CompareExchange(ref value, newState, oldState) != oldState);
			return newState;
		}

		/// <summary>
		/// Implements lock-free update pattern implementation based on compare-and-swap loop
		/// </summary>
		/// <remarks>
		/// Uses the same approach that used by c# compiler in event subscription methods
		/// </remarks>
		// BASEDON: https://github.com/dotnet/roslyn/blob/56f605c41915317ccdb925f66974ee52282609e7/src/Compilers/Core/Portable/InternalUtilities/ThreadSafeFlagOperations.cs
		public static float Update(ref float value, float newValue, Func<float, float, float> updateCallback)
		{
			float oldState, newState;
			do
			{
				oldState = value;
				newState = updateCallback(oldState, newValue);
			}
			while (Interlocked.CompareExchange(ref value, newState, oldState) != oldState);
			return newState;
		}
		#endregion

		#region int overloads
		/// <summary>
		/// Initialize the value referenced by <paramref name="target"/> in a thread-safe manner.
		/// The value is changed to <paramref name="value"/> only if the current value is default(int).
		/// </summary>
		/// <param name="target">Reference to the target location.</param>
		/// <param name="value">The value to use if the target is equal to default(int).</param>
		/// <returns>
		/// The new value referenced by <paramref name="target"/>.
		/// Note that this is nearly always more useful than the usual
		/// return from <see cref="Interlocked.CompareExchange(ref int, int, int)"/>
		/// because it saves another read to <paramref name="target"/>.
		/// </returns>
		public static int Initialize(ref int target, int value) =>
			Initialize(ref target, value, default(int));

		/// <summary>
		/// Initialize the value referenced by <paramref name="target"/> in a thread-safe manner.
		/// The value is changed to <paramref name="initializedValue"/> only if the current value
		/// is <paramref name="uninitializedValue"/>.
		/// </summary>
		/// <param name="target">Reference to the target location.</param>
		/// <param name="initializedValue">The value to use if the target is currently uninitialized.</param>
		/// <param name="uninitializedValue">The uninitialized value.</param>
		/// <returns>
		/// The new value referenced by <paramref name="target"/>.
		/// Note that this is nearly always more useful than the usual
		/// return from <see cref="Interlocked.CompareExchange(ref int, int, int)"/>
		/// because it saves another read to <paramref name="target"/>.
		/// </returns>
		public static int Initialize(ref int target, int initializedValue, int uninitializedValue)
		{
			DebugCode.AssertArgument(
				initializedValue != uninitializedValue,
				nameof(initializedValue),
				"The values of uninitializedValue and initializedValue should not match");

			var oldValue = Interlocked.CompareExchange(ref target, initializedValue, uninitializedValue);
			return oldValue == uninitializedValue ? initializedValue : oldValue;
		}

		/// <summary>
		/// Implements lock-free update pattern implementation based on compare-and-swap loop
		/// </summary>
		/// <remarks>
		/// Uses the same approach that used by c# compiler in event subscription methods
		/// </remarks>
		// BASEDON: https://github.com/dotnet/roslyn/blob/56f605c41915317ccdb925f66974ee52282609e7/src/Compilers/Core/Portable/InternalUtilities/ThreadSafeFlagOperations.cs
		public static int Update(ref int value, Func<int, int> updateCallback)
		{
			int oldState, newState;
			do
			{
				oldState = value;
				newState = updateCallback(oldState);
			}
			while (Interlocked.CompareExchange(ref value, newState, oldState) != oldState);
			return newState;
		}

		/// <summary>
		/// Implements lock-free update pattern implementation based on compare-and-swap loop
		/// </summary>
		/// <remarks>
		/// Uses the same approach that used by c# compiler in event subscription methods
		/// </remarks>
		// BASEDON: https://github.com/dotnet/roslyn/blob/56f605c41915317ccdb925f66974ee52282609e7/src/Compilers/Core/Portable/InternalUtilities/ThreadSafeFlagOperations.cs
		public static int Update(ref int value, int newValue, Func<int, int, int> updateCallback)
		{
			int oldState, newState;
			do
			{
				oldState = value;
				newState = updateCallback(oldState, newValue);
			}
			while (Interlocked.CompareExchange(ref value, newState, oldState) != oldState);
			return newState;
		}
		#endregion

		#region long overloads
		/// <summary>
		/// Initialize the value referenced by <paramref name="target"/> in a thread-safe manner.
		/// The value is changed to <paramref name="value"/> only if the current value is default(long).
		/// </summary>
		/// <param name="target">Reference to the target location.</param>
		/// <param name="value">The value to use if the target is equal to default(long).</param>
		/// <returns>
		/// The new value referenced by <paramref name="target"/>.
		/// Note that this is nearly always more useful than the usual
		/// return from <see cref="Interlocked.CompareExchange(ref long, long, long)"/>
		/// because it saves another read to <paramref name="target"/>.
		/// </returns>
		public static long Initialize(ref long target, long value) =>
			Initialize(ref target, value, default(long));

		/// <summary>
		/// Initialize the value referenced by <paramref name="target"/> in a thread-safe manner.
		/// The value is changed to <paramref name="initializedValue"/> only if the current value
		/// is <paramref name="uninitializedValue"/>.
		/// </summary>
		/// <param name="target">Reference to the target location.</param>
		/// <param name="initializedValue">The value to use if the target is currently uninitialized.</param>
		/// <param name="uninitializedValue">The uninitialized value.</param>
		/// <returns>
		/// The new value referenced by <paramref name="target"/>.
		/// Note that this is nearly always more useful than the usual
		/// return from <see cref="Interlocked.CompareExchange(ref long, long, long)"/>
		/// because it saves another read to <paramref name="target"/>.
		/// </returns>
		public static long Initialize(ref long target, long initializedValue, long uninitializedValue)
		{
			DebugCode.AssertArgument(
				initializedValue != uninitializedValue,
				nameof(initializedValue),
				"The values of uninitializedValue and initializedValue should not match");

			var oldValue = Interlocked.CompareExchange(ref target, initializedValue, uninitializedValue);
			return oldValue == uninitializedValue ? initializedValue : oldValue;
		}

		/// <summary>
		/// Implements lock-free update pattern implementation based on compare-and-swap loop
		/// </summary>
		/// <remarks>
		/// Uses the same approach that used by c# compiler in event subscription methods
		/// </remarks>
		// BASEDON: https://github.com/dotnet/roslyn/blob/56f605c41915317ccdb925f66974ee52282609e7/src/Compilers/Core/Portable/InternalUtilities/ThreadSafeFlagOperations.cs
		public static long Update(ref long value, Func<long, long> updateCallback)
		{
			long oldState, newState;
			do
			{
				oldState = value;
				newState = updateCallback(oldState);
			}
			while (Interlocked.CompareExchange(ref value, newState, oldState) != oldState);
			return newState;
		}

		/// <summary>
		/// Implements lock-free update pattern implementation based on compare-and-swap loop
		/// </summary>
		/// <remarks>
		/// Uses the same approach that used by c# compiler in event subscription methods
		/// </remarks>
		// BASEDON: https://github.com/dotnet/roslyn/blob/56f605c41915317ccdb925f66974ee52282609e7/src/Compilers/Core/Portable/InternalUtilities/ThreadSafeFlagOperations.cs
		public static long Update(ref long value, long newValue, Func<long, long, long> updateCallback)
		{
			long oldState, newState;
			do
			{
				oldState = value;
				newState = updateCallback(oldState, newValue);
			}
			while (Interlocked.CompareExchange(ref value, newState, oldState) != oldState);
			return newState;
		}
		#endregion

		#region T overloads
		/// <summary>
		/// Initialize the value referenced by <paramref name="target"/> in a thread-safe manner.
		/// The value is changed to <paramref name="value"/> only if the current value is default(T).
		/// </summary>
		/// <typeparam name="T">Type of value.</typeparam>
		/// <param name="target">Reference to the target location.</param>
		/// <param name="value">The value to use if the target is equal to default(T).</param>
		/// <returns>
		/// The new value referenced by <paramref name="target"/>.
		/// Note that this is nearly always more useful than the usual
		/// return from <see cref="Interlocked.CompareExchange{T}(ref T, T, T)"/>
		/// because it saves another read to <paramref name="target"/>.
		/// </returns>
		public static T Initialize<T>(ref T target, [NotNull] T value)
			where T : class =>
			Initialize(ref target, value, default(T));

		/// <summary>
		/// Initialize the value referenced by <paramref name="target"/> in a thread-safe manner.
		/// The value is changed to <paramref name="initializedValue"/> only if the current value
		/// is <paramref name="uninitializedValue"/>.
		/// </summary>
		/// <typeparam name="T">Type of value.</typeparam>
		/// <param name="target">Reference to the target location.</param>
		/// <param name="initializedValue">The value to use if the target is currently uninitialized.</param>
		/// <param name="uninitializedValue">The uninitialized value.</param>
		/// <returns>
		/// The new value referenced by <paramref name="target"/>.
		/// Note that this is nearly always more useful than the usual
		/// return from <see cref="Interlocked.CompareExchange{T}(ref T, T, T)"/>
		/// because it saves another read to <paramref name="target"/>.
		/// </returns>
		public static T Initialize<T>(ref T target, T initializedValue, T uninitializedValue)
			where T : class
		{
			DebugCode.AssertArgument(
				initializedValue != uninitializedValue,
				nameof(initializedValue),
				"The values of uninitializedValue and initializedValue should not match");

			var oldValue = Interlocked.CompareExchange(ref target, initializedValue, uninitializedValue);
			return oldValue == uninitializedValue ? initializedValue : oldValue;
		}

		/// <summary>
		/// Implements lock-free update pattern implementation based on compare-and-swap loop
		/// </summary>
		/// <remarks>
		/// Uses the same approach that used by c# compiler in event subscription methods
		/// </remarks>
		// BASEDON: https://github.com/dotnet/roslyn/blob/56f605c41915317ccdb925f66974ee52282609e7/src/Compilers/Core/Portable/InternalUtilities/ThreadSafeFlagOperations.cs
		public static T Update<T>(ref T value, Func<T, T> updateCallback)
			where T : class
		{
			T oldState, newState;
			do
			{
				oldState = value;
				newState = updateCallback(oldState);
			}
			while (Interlocked.CompareExchange(ref value, newState, oldState) != oldState);
			return newState;
		}

		/// <summary>
		/// Implements lock-free update pattern implementation based on compare-and-swap loop
		/// </summary>
		/// <remarks>
		/// Uses the same approach that used by c# compiler in event subscription methods
		/// </remarks>
		// BASEDON: https://github.com/dotnet/roslyn/blob/56f605c41915317ccdb925f66974ee52282609e7/src/Compilers/Core/Portable/InternalUtilities/ThreadSafeFlagOperations.cs
		public static T Update<T>(ref T value, T newValue, Func<T, T, T> updateCallback)
			where T : class
		{
			T oldState, newState;
			do
			{
				oldState = value;
				newState = updateCallback(oldState, newValue);
			}
			while (Interlocked.CompareExchange(ref value, newState, oldState) != oldState);
			return newState;
		}
		#endregion
	}
}