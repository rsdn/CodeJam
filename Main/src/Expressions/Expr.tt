<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ include file="$(SolutionDir)T4.Reusable\Autogenerated.ttinclude" #>
using System;
using System.Linq.Expressions;

using JetBrains.Annotations;

namespace CodeJam.Expressions
{
	/// <summary>
	/// Provides helper methods for Action and Func delegates.
	/// </summary>
	public static class Expr
	{
<#
	WriteRegionLine("Action<...>");
	for (var i = 0; i < 8; i++)
	{
		if (i > 0)
			WriteLine("");
		EmitAction(i);
	}

	WriteRegionLine("Func<...>");
	for (var i = 0; i < 8; i++)
	{
		if (i > 0)
			WriteLine("");
		EmitFunc(i);
	}

	FlushRegions();
#>
	}
}<#+

	private void EmitAction(int argCount)
	{
		var typeList = argCount == 0?
			"" :
			"<" + List(argCount, n => "T" + n, ", ") + ">";
#>
		/// <summary>Helper for type inference from the lambda expression.</summary>
<#+		for (var i = 1; i <= argCount; i++) {#>
		/// <typeparam name="T<#=i#>">The type of argument #<#=i#>.</typeparam>
<#+		}#>
		/// <param name="actionExpression">The lambda expression.</param>
		/// <returns>The lambda expression passed.</returns>
		[Pure, NotNull]
		public static Expression<Action<#=typeList#>> Action<#=typeList#>(
			[NotNull] Expression<Action<#=typeList#>> actionExpression)
		{
			Code.NotNull(actionExpression, nameof(actionExpression));
			return actionExpression;
		}
<#+
	}

	private void EmitFunc(int argCount)
	{
		var typeList = argCount == 0?
			"<TResult>" :
			"<" + List(argCount, n => "T" + n, ", ") + ", TResult" + ">";#>
		/// <summary>Helper for type inference from the lambda expression.</summary>
<#+		for (var i = 1; i <= argCount; i++) {#>
		/// <typeparam name="T<#=i#>">The type of argument #<#=i#>.</typeparam>
<#+		}#>
		/// <typeparam name="TResult">The result type.</typeparam>
		/// <param name="funcExpression">The lambda expression.</param>
		/// <returns>The lambda expression passed.</returns>
		[Pure, NotNull]
		public static Expression<Func<#=typeList#>> Func<#=typeList#>(
			[NotNull] Expression<Func<#=typeList#>> funcExpression)
		{
			Code.NotNull(funcExpression, nameof(funcExpression));
			return funcExpression;
		}
<#+
	}
#>