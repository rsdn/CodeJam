//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using static CodeJam.DebugCode;

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;

using CodeJam.Arithmetic;
using CodeJam.Strings;

using JetBrains.Annotations;

using static CodeJam.PlatformDependent;

namespace CodeJam
{
	/// <summary>Assertions class.</summary>
	[PublicAPI]
	public static partial class DebugCode
	{
		#region Argument validation
		/// <summary>Ensures that <paramref name="arg"/> != <c>null</c></summary>
		/// <typeparam name="T">Type of the value. Auto-inferred in most cases</typeparam>
		/// <param name="arg">The argument.</param>
		/// <param name="argName">Name of the argument.</param>
		[Conditional(DebugCondition), DebuggerHidden, MethodImpl(AggressiveInlining)]
		[AssertionMethod]
		public static void NotNull<T>(
			[CanBeNull, NoEnumeration, AssertionCondition(AssertionConditionType.IS_NOT_NULL)] T arg,
			[NotNull, InvokerParameterName] string argName) where T : class
		{
			if (arg == null)
				throw CodeExceptions.ArgumentNull(argName);
		}

		/// <summary>Ensures that <paramref name="arg"/> != <c>null</c></summary>
		/// <typeparam name="T">Type of the value. Auto-inferred in most cases</typeparam>
		/// <param name="arg">The argument.</param>
		/// <param name="argName">Name of the argument.</param>
		[Conditional(DebugCondition), DebuggerHidden, MethodImpl(AggressiveInlining)]
		[AssertionMethod]
		public static void NotNull<T>(
			[CanBeNull, AssertionCondition(AssertionConditionType.IS_NOT_NULL)] T? arg,
			[NotNull, InvokerParameterName] string argName) where T : struct
		{
			if (arg == null)
				throw CodeExceptions.ArgumentNull(argName);
		}

		/// <summary>Ensures that <paramref name="arg"/> is not null nor empty</summary>
		/// <param name="arg">The argument.</param>
		/// <param name="argName">Name of the argument.</param>
		[Conditional(DebugCondition), DebuggerHidden, MethodImpl(AggressiveInlining)]
		[AssertionMethod]
		public static void NotNullNorEmpty(
			[CanBeNull] string arg,
			[NotNull, InvokerParameterName] string argName)
		{
			if (string.IsNullOrEmpty(arg))
				throw CodeExceptions.ArgumentNullOrEmpty(argName);
		}

		/// <summary>Ensures that <paramref name="arg"/> is not null nor white space</summary>
		/// <param name="arg">The argument.</param>
		/// <param name="argName">Name of the argument.</param>
		[Conditional(DebugCondition), DebuggerHidden, MethodImpl(AggressiveInlining)]
		[AssertionMethod]
		public static void NotNullNorWhiteSpace(
			[CanBeNull] string arg,
			[NotNull, InvokerParameterName] string argName)
		{
			if (arg.IsNullOrWhiteSpace())
				throw CodeExceptions.ArgumentNullOrWhiteSpace(argName);
		}

		/// <summary>Assertion for the argument value</summary>
		/// <param name="condition">The condition to check</param>
		/// <param name="argName">Name of the argument.</param>
		/// <param name="message">The message.</param>
		[Conditional(DebugCondition), DebuggerHidden, MethodImpl(AggressiveInlining)]
		[AssertionMethod]
		public static void AssertArgument(
			[AssertionCondition(AssertionConditionType.IS_TRUE)] bool condition,
			[NotNull, InvokerParameterName] string argName,
			[NotNull] string message)
		{
			if (!condition)
				throw CodeExceptions.Argument(argName, message);
		}

		/// <summary>Assertion for the argument value</summary>
		/// <param name="condition">The condition to check</param>
		/// <param name="argName">Name of the argument.</param>
		/// <param name="messageFormat">The message format.</param>
		/// <param name="args">The arguments.</param>
		[Conditional(DebugCondition), DebuggerHidden, MethodImpl(AggressiveInlining)]
		[AssertionMethod, StringFormatMethod("messageFormat")]
		public static void AssertArgument(
			[AssertionCondition(AssertionConditionType.IS_TRUE)] bool condition,
			[NotNull, InvokerParameterName] string argName,
			[NotNull] string messageFormat,
			[CanBeNull] params object[] args)
		{
			if (!condition)
				throw CodeExceptions.Argument(argName, messageFormat, args);
		}
		#endregion

		#region Argument validation - in range
		/// <summary>Assertion for the argument in range</summary>
		/// <param name="value">The value.</param>
		/// <param name="argName">Name of the argument.</param>
		/// <param name="fromValue">From value (inclusive).</param>
		/// <param name="toValue">To value (inclusive).</param>
		[Conditional(DebugCondition), DebuggerHidden, MethodImpl(AggressiveInlining)]
		[AssertionMethod]
		public static void InRange(
			int value,
			[NotNull, InvokerParameterName] string argName,
			int fromValue,
			int toValue)
		{
			if (value < fromValue || value > toValue)
				throw CodeExceptions.ArgumentOutOfRange(argName, value, fromValue, toValue);
		}

		/// <summary>Assertion for the argument in range</summary>
		/// <typeparam name="T">Type of the value</typeparam>
		/// <param name="value">The value.</param>
		/// <param name="argName">Name of the argument.</param>
		/// <param name="fromValue">From value (inclusive).</param>
		/// <param name="toValue">To value (inclusive).</param>
		[Conditional(DebugCondition), DebuggerHidden, MethodImpl(AggressiveInlining)]
		[AssertionMethod]
		public static void InRange<T>(
			T value,
			[NotNull, InvokerParameterName] string argName,
			T fromValue,
			T toValue)
		{
			if (Operators<T>.LessThan(value, fromValue) || Operators<T>.GreaterThan(value, toValue))
				throw CodeExceptions.ArgumentOutOfRange(argName, value, fromValue, toValue);
		}
		#endregion

		#region Argument validation - valid index
		/// <summary>Assertion for index in range</summary>
		/// <param name="index">The index.</param>
		/// <param name="argName">Name of the argument.</param>
		[Conditional(DebugCondition), DebuggerHidden, MethodImpl(AggressiveInlining)]
		[AssertionMethod]
		public static void ValidIndex(
			int index,
			[NotNull, InvokerParameterName] string argName)
		{
			if (index < 0)
				throw CodeExceptions.IndexOutOfRange(argName, index, 0, int.MaxValue);
		}

		/// <summary>Assertion for index in range</summary>
		/// <param name="index">The index.</param>
		/// <param name="argName">Name of the argument.</param>
		/// <param name="length">The length.</param>
		[Conditional(DebugCondition), DebuggerHidden, MethodImpl(AggressiveInlining)]
		[AssertionMethod]
		public static void ValidIndex(
			int index,
			[NotNull, InvokerParameterName] string argName,
			int length)
		{
			if (index < 0 || index >= length)
				throw CodeExceptions.IndexOutOfRange(argName, index, 0, length);
		}

		/// <summary>Assertion for from-to index pair</summary>
		/// <param name="fromIndex">From index.</param>
		/// <param name="fromIndexName">Name of from index.</param>
		/// <param name="toIndex">To index.</param>
		/// <param name="toIndexName">Name of to index.</param>
		/// <param name="length">The length.</param>
		[Conditional(DebugCondition), DebuggerHidden, MethodImpl(AggressiveInlining)]
		[AssertionMethod]
		public static void ValidIndexPair(
			int fromIndex,
			[NotNull, InvokerParameterName] string fromIndexName,
			int toIndex,
			[NotNull, InvokerParameterName] string toIndexName,
			int length)
		{
			ValidIndex(fromIndex, fromIndexName, length);

			if (toIndex < fromIndex || toIndex >= length)
				throw CodeExceptions.IndexOutOfRange(toIndexName, toIndex, fromIndex, length);
		}

		/// <summary>Assertion for startIndex-count pair</summary>
		/// <param name="startIndex">The start index.</param>
		/// <param name="startIndexName">Start name of the index.</param>
		/// <param name="count">The count.</param>
		/// <param name="countName">Name of the count.</param>
		/// <param name="length">The length.</param>
		[Conditional(DebugCondition), DebuggerHidden, MethodImpl(AggressiveInlining)]
		[AssertionMethod]
		public static void ValidIndexAndCount(
			int startIndex,
			[NotNull, InvokerParameterName] string startIndexName,
			int count,
			[NotNull, InvokerParameterName] string countName,
			int length)
		{
			ValidIndex(startIndex, startIndexName, length);

			InRange(count, countName, 0, length - startIndex);
		}
		#endregion

		#region State validation
		/// <summary>State assertion</summary>
		/// <param name="condition">The condition to check</param>
		/// <param name="message">The message.</param>
		[Conditional(DebugCondition), DebuggerHidden, MethodImpl(AggressiveInlining)]
		[AssertionMethod]
		public static void AssertState(
			[AssertionCondition(AssertionConditionType.IS_TRUE)] bool condition,
			[NotNull] string message)
		{
			if (!condition)
				throw CodeExceptions.InvalidOperation(message);
		}

		/// <summary>State assertion</summary>
		/// <param name="condition">The condition to check</param>
		/// <param name="messageFormat">The message format.</param>
		/// <param name="args">The arguments.</param>
		[Conditional(DebugCondition), DebuggerHidden, MethodImpl(AggressiveInlining)]
		[AssertionMethod, StringFormatMethod("messageFormat")]
		public static void AssertState(
			[AssertionCondition(AssertionConditionType.IS_TRUE)] bool condition,
			[NotNull] string messageFormat,
			[CanBeNull] params object[] args)
		{
			if (!condition)
				throw CodeExceptions.InvalidOperation(messageFormat, args);
		}
		#endregion
	}
}