<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ include file="..\..\T4.Reusable\Autogenerated.ttinclude" #>
using System;
using System.Linq.Expressions;

using JetBrains.Annotations;

namespace CodeJam
{
	/// <summary>
	/// Helper methods for <see cref="Func{TResult}"/> and <seealso cref="Action"/> delegates.
	/// </summary>
	public static partial class Fn
	{
<#
	WriteRegionLine("Action<...>");
	for (var i = 0; i < 8; i++)
	{
		if (i > 0)
			WriteLine("");
		EmitAction(i);
	}

	WriteRegionLine("Func<...>");
	for (var i = 0; i < 8; i++)
	{
		if (i > 0)
			WriteLine("");
		EmitFunc(i);
	}

	FlushRegions();
#>
	}
}<#+

	private void EmitAction(int argCount)
	{
		var typeList = argCount == 0?
			"" :
			"<" + List(argCount, n => "T" + n, ", ") + ">";
#>
		/// <summary>Helper for type inference from the lambda callback.</summary>
<#+		for (var i = 1; i <= argCount; i++) {#>
		/// <typeparam name="T<#=i#>">The type of argument #<#=i#>.</typeparam>
<#+		}#>
		/// <param name="action">The lambda callback.</param>
		/// <returns>The lambda callback passed.</returns>
		[Pure, NotNull]
		public static Action<#=typeList#> Action<#=typeList#>(
			[NotNull] Action<#=typeList#> action)
		{
			Code.NotNull(action, nameof(action));
			return action;
		}
<#+
	}

	private void EmitFunc(int argCount)
	{
		var typeList = argCount == 0?
			"<TResult>" :
			"<" + List(argCount, n => "T" + n, ", ") + ", TResult" + ">";#>
		/// <summary>Helper for type inference from the lambda callback.</summary>
<#+		for (var i = 1; i <= argCount; i++) {#>
		/// <typeparam name="T<#=i#>">The type of argument #<#=i#>.</typeparam>
<#+		}#>
		/// <typeparam name="TResult">The result type.</typeparam>
		/// <param name="func">The lambda callback.</param>
		/// <returns>The lambda callback passed.</returns>
		[Pure, NotNull]
		public static Func<#=typeList#> Func<#=typeList#>(
			[NotNull] Func<#=typeList#> func)
		{
			Code.NotNull(func, nameof(func));
			return func;
		}
<#+
	}
#>